from fastapi import FastAPI, Depends, UploadFile, File, BackgroundTasks, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import RedirectResponse, JSONResponse


from sqlalchemy.orm import Session
from typing import List
import os

from ..database.session import SessionLocal, init_db
from ..ingestion.processor import MaterialProcessor
from ..ingestion.chunking import Chunker
from ..rag.embedder import Embedder, RAGService
from ..rag.evaluation import EvaluationService
from ..quiz.professor_bot import ProfessorBot
from ..quiz.planner import TopicPlanner
from ..quiz.quiz_manager import QuizManager
from ..database.models.question import Question, QuestionStatus
from ..database.models.hierarchy import Chapter, Section, Subsection, RawMaterial
from ..database.models.transcript import Transcript, Quiz


app = FastAPI(title="Edurank AI Assessment System")

# Enable CORS with explicit null support for local files
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*", "null"],
    allow_credentials=False,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.exception_handler(Exception)
async def global_exception_handler(request, exc):
    print(f"GLOBAL ERROR: {exc}")
    return JSONResponse(
        status_code=500,
        content={"message": str(exc)},
        headers={"Access-Control-Allow-Origin": "*"}
    )



@app.get("/")
def read_root():
    return RedirectResponse(url="/docs")


# Dependency
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

import google.generativeai as genai
from dotenv import load_dotenv

load_dotenv()
genai.configure(api_key=os.getenv("GOOGLE_API_KEY"))

@app.on_event("startup")
def startup_event():
    init_db()


# --- Professor Endpoints ---

def run_material_ingestion(course_id: int, file_path: str):
    """Background worker with its own DB session."""
    db = SessionLocal()
    try:
        print(f"DEBUG: Starting background ingestion for {file_path}")
        processor = MaterialProcessor(db)
        processor.process_material(course_id, file_path, "pdf")
        print(f"DEBUG: Background ingestion complete for {file_path}")
    except Exception as e:
        print(f"ERROR in background ingestion: {e}")
    finally:
        db.close()

@app.post("/professor/upload/{course_id}")
async def upload_material(
    course_id: int, 
    background_tasks: BackgroundTasks, 
    file: UploadFile = File(...), 
    db: Session = Depends(get_db)
):
    """Uploads material and triggers hierarchical ingestion."""
    # Save file locally
    file_path = f"uploads/{file.filename}"
    os.makedirs("uploads", exist_ok=True)
    with open(file_path, "wb") as f:
        f.write(await file.read())
    
    # Process hierarchy and chunks in background with fresh session
    print(f"DEBUG: Triggering background ingestion for course {course_id}, file: {file.filename}")
    background_tasks.add_task(run_material_ingestion, course_id, file_path)
    
    return {"status": "File uploaded. Processing in background.", "filename": file.filename}



@app.get("/professor/questions/pending", response_model=List[dict])
def get_pending_questions(db: Session = Depends(get_db)):
    """Fetch questions generated by AI but not yet approved."""
    print("DEBUG: Fetching pending questions...")
    questions = db.query(Question).filter_by(status=QuestionStatus.PENDING).all()
    return [{"id": q.id, "text": q.question_text, "answer": q.ideal_answer} for q in questions]


@app.post("/professor/questions/{question_id}/review")
def review_question(question_id: int, status: str, db: Session = Depends(get_db)):
    """Approve or reject a question."""
    question = db.query(Question).get(question_id)
    if not question:
        raise HTTPException(status_code=404, detail="Question not found")
    
    if status == "approve":
        question.status = QuestionStatus.APPROVED
    elif status == "reject":
        question.status = QuestionStatus.REJECTED
    
    db.commit()
    return {"status": "Updated"}

@app.post("/professor/generate/{course_id}")
def trigger_generation(course_id: int, total_marks: int = 100, db: Session = Depends(get_db)):
    """Triggers the ProfessorBot to generate questions based on marks."""
    print(f"Triggering question generation for course {course_id}...")
    planner = TopicPlanner(db)
    rag = RAGService(db, Embedder(db))
    bot = ProfessorBot(db, rag, planner)
    res = bot.generate_questions_for_course(course_id, total_marks=total_marks)
    print(f"Generation result: {res}")
    return {"status": "Generation request processed", "details": res}


@app.get("/professor/simulate/next")
def get_next_simulation_question(course_id: int, exclude_ids: str = "", db: Session = Depends(get_db)):
    """Fetch a question for simulation/testing with variety and duplicate prevention."""
    exclude_list = [int(i) for i in exclude_ids.split(",") if i.strip()]
    
    # 1. Potential pool: APPROVED or PENDING, not in exclude_list
    query = db.query(Question).filter(
        Question.subsection_id.in_(
            db.query(Subsection.id).join(Section).join(Chapter).filter(Chapter.course_id == course_id).scalar_subquery()
        ),
        Question.status.in_([QuestionStatus.APPROVED, QuestionStatus.PENDING]),
        ~Question.id.in_(exclude_list)
    )
    
    # 2. Strategy: Mixed Novelty (Exposure) & Quality (Likes)
    # This addresses "More of such" (Quality) while maintaining coverage (Novelty)
    
    # Pool A: Novelty - Least seen questions first
    pool_novelty = query.order_by(
        (Question.upvotes + Question.downvotes).asc()
    ).limit(7).all()

    # Pool B: Quality - Highly ranked questions (More of such)
    # We filter by approved and those that have positive sentiment
    pool_quality = query.filter(Question.upvotes > Question.downvotes).order_by(
        (Question.upvotes - Question.downvotes).desc()
    ).limit(7).all()

    # Merge candidates (Unique IDs)
    candidates = {q.id: q for q in pool_novelty + pool_quality}.values()
    candidates = list(candidates)

    if not candidates:
        if exclude_list:
            return {"reset": True, "message": "Syllabus variety cycle complete. Resetting."}
        raise HTTPException(status_code=404, detail="No assessment content found.")
    
    import random
    random.shuffle(candidates)
    question = candidates[0]
        
    return {
        "id": question.id, 
        "text": question.question_text, 
        "answer": question.ideal_answer, 
        "status": question.status.value,
        "context": f"{question.subsection.section.chapter.title} > {question.subsection.section.title}"
    }




@app.post("/professor/questions/{question_id}/rank")
def rank_question(question_id: int, interaction: str, db: Session = Depends(get_db)):
    """Rank a question (like/dislike) during simulation."""
    question = db.query(Question).get(question_id)
    if not question:
        raise HTTPException(status_code=404, detail="Question not found")
        
    if interaction == "like":
        question.upvotes += 1
    elif interaction == "dislike":
        question.downvotes += 1
        
    db.commit()
    return {"status": "Ranked", "upvotes": question.upvotes, "downvotes": question.downvotes}

@app.post("/professor/quiz/create")
def create_exam_config(course_id: int, title: str, duration: int, total_marks: int, instructions: str = None, db: Session = Depends(get_db)):
    """Saves the exam configuration including system instructions."""
    quiz = Quiz(
        course_id=course_id, 
        title=title, 
        duration_minutes=duration, 
        total_marks=total_marks,
        instructions=instructions
    )
    db.add(quiz)
    db.commit()
    return {"quiz_id": quiz.id}

# --- Student Endpoints ---

@app.post("/student/quiz/start/{course_id}")
def start_quiz(course_id: int, student_id: int, db: Session = Depends(get_db)):
    """Starts a quiz session using the QuizManager."""
    rag = RAGService(db, Embedder(db))
    eval_svc = EvaluationService(db, rag)
    manager = QuizManager(db, eval_svc)
    
    quiz_id = manager.start_quiz(course_id, student_id)
    return {"quiz_id": quiz_id}

@app.post("/student/quiz/{quiz_id}/submit")
def submit_answer(
    quiz_id: int, 
    question_id: int, 
    answer: str, 
    student_id: int, 
    db: Session = Depends(get_db)
):
    """Submits an answer for evaluation and audit logging."""
    rag = RAGService(db, Embedder(db))
    eval_svc = EvaluationService(db, rag)
    manager = QuizManager(db, eval_svc)
    
    result = manager.submit_answer(student_id, quiz_id, question_id, answer)
    return result

# --- Audit Endpoints ---

@app.get("/professor/transcripts/{course_id}")
def get_transcripts(course_id: int, db: Session = Depends(get_db)):
    """Full transcripts for professor review."""
    transcripts = db.query(Transcript).all() # Simple fetch
    return transcripts
