from fastapi import FastAPI, Depends, UploadFile, File, BackgroundTasks, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import RedirectResponse, JSONResponse


from sqlalchemy.orm import Session
from typing import List, Dict
import os

from ..database.session import SessionLocal, init_db
from ..ingestion.processor import MaterialProcessor
from ..ingestion.chunking import Chunker
from ..rag.embedder import Embedder, RAGService
from ..rag.evaluation import EvaluationService
from ..quiz.professor_bot import ProfessorBot
from ..quiz.planner import TopicPlanner
from ..quiz.quiz_manager import QuizManager
from ..database.models.question import Question, QuestionStatus
from ..database.models.hierarchy import Chapter, Section, Subsection, RawMaterial
from ..database.models.transcript import Transcript, Quiz


app = FastAPI(title="Dialogue box AI System")

# Enable CORS with explicit null support for local files
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*", "null"],
    allow_credentials=False,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.exception_handler(Exception)
async def global_exception_handler(request, exc):
    print(f"GLOBAL ERROR: {exc}")
    return JSONResponse(
        status_code=500,
        content={"message": str(exc)},
        headers={"Access-Control-Allow-Origin": "*"}
    )



@app.get("/")
def read_root():
    return RedirectResponse(url="/docs")


# Dependency
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

import google.generativeai as genai
from dotenv import load_dotenv

load_dotenv()
genai.configure(api_key=os.getenv("GOOGLE_API_KEY"))

@app.on_event("startup")
def startup_event():
    init_db()

# --- Auth & User Endpoints ---

@app.post("/auth/register")
def register_professor(data: dict, db: Session = Depends(get_db)):
    """Registers a professor with @ahduni.edu.in restriction."""
    from ..database.models.user import User, UserRole
    email = data.get("email")
    if not email or not email.endswith("@ahduni.edu.in"):
        raise HTTPException(status_code=400, detail="Only @ahduni.edu.in emails allowed")
    
    user = db.query(User).filter_by(email=email).first()
    if not user:
        user = User(
            email=email,
            full_name=data.get("full_name"),
            firebase_uid=data.get("firebase_uid"),
            role=UserRole.PROFESSOR
        )
        db.add(user)
        db.commit()
    return {"status": "success", "user_id": user.id}

@app.get("/professor/assessments")
def get_professor_assessments(db: Session = Depends(get_db)):
    """List all assessments for the professor dashboard."""
    quizzes = db.query(Quiz).all() # Filter by professor in future
    return [{
        "id": q.id,
        "title": q.title,
        "course_name": q.course.title if q.course else "Unknown Course",
        "total_questions": q.total_questions,
        "is_finalized": q.is_finalized == 1,
        "password": q.password,
        "transcripts_count": len(q.transcripts)
    } for q in quizzes]


# --- Professor Endpoints ---

def run_material_ingestion(course_id: int, file_path: str):
    """Background worker with its own DB session."""
    db = SessionLocal()
    try:
        print(f"DEBUG: Starting background ingestion for {file_path}")
        processor = MaterialProcessor(db)
        processor.process_material(course_id, file_path, "pdf")
        print(f"DEBUG: Background ingestion complete for {file_path}")
    except Exception as e:
        print(f"ERROR in background ingestion: {e}")
    finally:
        db.close()

@app.post("/professor/upload/{course_id}")
async def upload_material(
    course_id: int, 
    background_tasks: BackgroundTasks, 
    file: UploadFile = File(...), 
    db: Session = Depends(get_db)
):
    """Uploads material and triggers hierarchical ingestion."""
    # Save file locally
    file_path = f"uploads/{file.filename}"
    os.makedirs("uploads", exist_ok=True)
    with open(file_path, "wb") as f:
        f.write(await file.read())
    
    # Process hierarchy and chunks in background with fresh session
    print(f"DEBUG: Triggering background ingestion for course {course_id}, file: {file.filename}")
    background_tasks.add_task(run_material_ingestion, course_id, file_path)
    
    return {"status": "File uploaded. Processing in background.", "filename": file.filename}



@app.get("/professor/questions/pending", response_model=List[dict])
def get_pending_questions(db: Session = Depends(get_db)):
    """Fetch questions generated by AI but not yet approved."""
    print("DEBUG: Fetching pending questions...")
    questions = db.query(Question).filter_by(status=QuestionStatus.PENDING).all()
    return [{"id": q.id, "text": q.question_text, "answer": q.ideal_answer} for q in questions]


@app.post("/professor/questions/{question_id}/review")
def review_question(question_id: int, status: str, db: Session = Depends(get_db)):
    """Approve or reject a question."""
    question = db.query(Question).get(question_id)
    if not question:
        raise HTTPException(status_code=404, detail="Question not found")
    
    if status == "approve":
        question.status = QuestionStatus.APPROVED
    elif status == "reject":
        question.status = QuestionStatus.REJECTED
    
    db.commit()
    return {"status": "Updated"}

@app.post("/professor/generate/{course_id}")
def trigger_generation(course_id: int, total_marks: int = 100, db: Session = Depends(get_db)):
    """Triggers the ProfessorBot to generate questions based on marks."""
    print(f"Triggering question generation for course {course_id}...")
    planner = TopicPlanner(db)
    rag = RAGService(db, Embedder(db))
    bot = ProfessorBot(db, rag, planner)
    res = bot.generate_questions_for_course(course_id, total_marks=total_marks)
    print(f"Generation result: {res}")
    return {"status": "Generation request processed", "details": res}


@app.get("/professor/ingestion-status/{course_id}")
def get_ingestion_status(course_id: int, db: Session = Depends(get_db)):
    """Fetch the progress status of material processing."""
    from ..database.models.course import Course
    course = db.query(Course).get(course_id)
    if not course:
        raise HTTPException(status_code=404, detail="Course not found")
    return {"status": course.ingestion_status.value}


@app.get("/professor/simulate/next")
def get_next_simulation_question(course_id: int, exclude_ids: str = "", history: str = "", db: Session = Depends(get_db)):
    """Fetch a question for simulation/testing with variety and adaptive history support."""
    # Parse history if provided (format: q|a,q|a)
    parsed_history = []
    if history:
        for turn in history.split(","):
            if "|" in turn:
                q, a = turn.split("|", 1)
                parsed_history.append({"q": q, "a": a})

    # Always use the Adaptive Bot Strategy for Simulation
    planner = TopicPlanner(db)
    rag = RAGService(db, Embedder(db))
    bot = ProfessorBot(db, rag, planner)
    
    # Fetch instructions for this course (from existing quiz)
    quiz_config = db.query(Quiz).filter_by(course_id=course_id).order_by(Quiz.id.desc()).first()
    bot.instructions = quiz_config.instructions if quiz_config else None
    
    # generate_single_question now handles Phase 0 (Greeting) and Graph-RAG
    question = bot.generate_single_question(course_id, history=parsed_history, is_simulation=True)
    
    if question:
        return {
            "id": question.id, 
            "text": question.question_text, 
            "answer": question.ideal_answer, 
            "status": question.status.value,
            "context": f"{question.subsection.section.chapter.title} > {question.subsection.section.title}" if question.subsection else "Adaptive Simulation"
        }

    # If we reach here, tell the user WHY.
    raise HTTPException(status_code=503, detail="The AI is currently processing or rate-limited. Please ensure syllabus data is uploaded and wait a moment.")

@app.post("/professor/questions/{question_id}/rank")
def rank_question(question_id: int, interaction: str, db: Session = Depends(get_db)):
    """Rank a question (like/dislike) during simulation."""
    question = db.query(Question).get(question_id)
    if not question:
        raise HTTPException(status_code=404, detail="Question not found")
        
    if interaction == "like":
        question.upvotes += 1
    elif interaction == "dislike":
        question.downvotes += 1
        
    db.commit()
    return {"status": "Ranked", "upvotes": question.upvotes, "downvotes": question.downvotes}

@app.post("/professor/quiz/create")
def create_exam_config(course_id: int, title: str, duration: int, total_marks: int, total_questions: int = 5, instructions: str = None, db: Session = Depends(get_db)):
    """Saves the exam configuration including system instructions."""
    quiz = Quiz(
        course_id=course_id, 
        title=title, 
        duration_minutes=duration, 
        total_marks=total_marks,
        total_questions=total_questions,
        instructions=instructions
    )
    db.add(quiz)
    db.commit()
    return {"quiz_id": quiz.id}

@app.put("/professor/quiz/{quiz_id}")
def update_quiz_details(quiz_id: int, data: dict, db: Session = Depends(get_db)):
    """Update assessment configuration."""
    quiz = db.query(Quiz).get(quiz_id)
    if not quiz:
        raise HTTPException(status_code=44, detail="Quiz not found")
    
    quiz.title = data.get("title", quiz.title)
    quiz.duration_minutes = data.get("duration", quiz.duration_minutes)
    quiz.instructions = data.get("instructions", quiz.instructions)
    # total_marks could also be updated if needed
    
    db.commit()
    return {"status": "updated"}

@app.post("/professor/quiz/{quiz_id}/finalize")
def finalize_quiz(quiz_id: int, password: str, db: Session = Depends(get_db)):
    """Locks the quiz and sets the access password."""
    quiz = db.query(Quiz).get(quiz_id)
    if not quiz:
        raise HTTPException(status_code=404, detail="Quiz not found")
    quiz.password = password
    quiz.is_finalized = 1
    db.commit()
    return {"status": "finalized"}

@app.post("/professor/quiz/{quiz_id}/password")
def update_quiz_password(quiz_id: int, password: str, db: Session = Depends(get_db)):
    """Updates the access password for a quiz."""
    quiz = db.query(Quiz).get(quiz_id)
    if not quiz:
        raise HTTPException(status_code=404, detail="Quiz not found")
    quiz.password = password
    db.commit()
    return {"status": "updated", "password": password}

@app.delete("/professor/quiz/{quiz_id}")
def delete_quiz(quiz_id: int, db: Session = Depends(get_db)):
    """Deletes an assessment and its dependencies."""
    quiz = db.query(Quiz).get(quiz_id)
    if not quiz:
        raise HTTPException(status_code=404, detail="Quiz not found")
    db.delete(quiz)
    db.commit()
    return {"status": "deleted"}

@app.get("/professor/quiz/{quiz_id}")
def get_quiz_details(quiz_id: int, db: Session = Depends(get_db)):
    """Fetch details for a specific quiz."""
    quiz = db.query(Quiz).get(quiz_id)
    if not quiz:
        raise HTTPException(status_code=404, detail="Quiz not found")
    return {
        "id": quiz.id,
        "title": quiz.title,
        "course_id": quiz.course_id,
        "duration_minutes": quiz.duration_minutes,
        "total_marks": quiz.total_marks,
        "total_questions": quiz.total_questions,
        "is_finalized": quiz.is_finalized == 1
    }

@app.get("/professor/quiz/{quiz_id}/student/{enrollment_id}/messages")
def get_student_transcript_messages(quiz_id: int, enrollment_id: str, db: Session = Depends(get_db)):
    """Fetch the full conversation history for a specific student in a quiz."""
    transcripts = db.query(Transcript).filter_by(
        quiz_id=quiz_id,
        enrollment_id=enrollment_id
    ).order_by(Transcript.created_at).all()
    
    messages = []
    for t in transcripts:
        # Each transcript record represents one Q&A turn
        messages.append({
            "role": "bot",
            "text": t.question.question_text if t.question else "N/A",
            "type": "question"
        })
        messages.append({
            "role": "user",
            "text": t.student_answer,
            "type": "answer"
        })
        
    return messages

# --- Student Endpoints ---
@app.get("/student/quiz/{quiz_id}/meta")
def get_quiz_meta(quiz_id: int, db: Session = Depends(get_db)):
    """Fetch basic info about a quiz for students (title, duration)."""
    quiz = db.query(Quiz).get(quiz_id)
    if not quiz or not quiz.is_finalized:
        raise HTTPException(status_code=404, detail="Quiz not found or not active")
    return {
        "title": quiz.title,
        "duration_minutes": quiz.duration_minutes,
        "total_questions": quiz.total_questions
    }


@app.post("/student/quiz/start/{quiz_id}")
def start_quiz(quiz_id: int, data: dict, db: Session = Depends(get_db)):
    """Starts a quiz session using the QuizManager."""
    quiz = db.query(Quiz).get(quiz_id)
    if not quiz:
        raise HTTPException(status_code=404, detail="Assessment not found")
    
    # Check password if quiz is finalized
    if quiz.is_finalized and quiz.password:
        provided_password = data.get("password")
        if provided_password != quiz.password:
            raise HTTPException(status_code=401, detail="Invalid access password")

    rag = RAGService(db, Embedder(db))
    eval_svc = EvaluationService(db, rag)
    manager = QuizManager(db, eval_svc)
    
    return {"quiz_id": quiz_id, "status": "authorized"}

@app.post("/student/quiz/{quiz_id}/submit")
def submit_answer(
    quiz_id: int, 
    data: dict, 
    db: Session = Depends(get_db)
):
    """Submits an answer for evaluation and audit logging."""
    rag = RAGService(db, Embedder(db))
    eval_svc = EvaluationService(db, rag)
    manager = QuizManager(db, eval_svc)
    
    result = manager.submit_answer(
        quiz_id=quiz_id,
        question_id=data.get("question_id"),
        answer_text=data.get("answer"),
        student_name=data.get("student_name"),
        enrollment_id=data.get("enrollment_id")
    )
    return result

@app.get("/student/quiz/{quiz_id}/next-question")
def get_student_next_question(quiz_id: int, enrollment_id: str, student_name: str = None, exclude_ids: str = "", db: Session = Depends(get_db)):
    """Fetch the next adaptive question based on student performance."""
    quiz = db.query(Quiz).get(quiz_id)
    if not quiz:
        raise HTTPException(status_code=404, detail="Quiz not found")

    # 1. Fetch Student History (Transcripts)
    transcripts = db.query(Transcript).filter_by(
        quiz_id=quiz_id,
        enrollment_id=enrollment_id
    ).order_by(Transcript.created_at.desc()).limit(3).all()

    history = []
    for t in transcripts:
        history.append({
            "q": t.question.question_text if t.question else "",
            "a": t.student_answer
        })

    # 2. Adaptive Generation JIT (<5s target)
    planner = TopicPlanner(db)
    rag = RAGService(db, Embedder(db))
    bot = ProfessorBot(db, rag, planner)
    bot.instructions = quiz.instructions # ENSURE INSTRUCTIONS ARE PASSED
    
    # Pass 15+ pre-generated IDs to avoid direct duplicates, but generate JIT for adaptivity
    exclude_list = [int(i) for i in exclude_ids.split(",") if i.strip()]
    
    # We strictly use JIT generation for students to ensure instruction adherence
    question = bot.generate_single_question(quiz.course_id, history=history, is_simulation=True, student_name=student_name)
    
    # If first JIT attempt fails (e.g. topic selected was empty), try one more time
    if not question:
        question = bot.generate_single_question(quiz.course_id, history=history, is_simulation=True, student_name=student_name)

    if not question:
        raise HTTPException(status_code=404, detail="The Professor is busy formulating your next challenge. Please refresh in a moment.")

    return {
        "id": question.id, 
        "text": question.question_text, 
        "answer": "HIDDEN_DURING_QUIZ", # SECURITY: Never leak the answer to the student
        "context": f"{question.subsection.section.chapter.title} > {question.subsection.section.title}" if question.subsection else "Adaptive Quiz"
    }

# --- Audit & Management Endpoints ---

@app.get("/professor/quiz/{quiz_id}/transcripts")
def list_student_transcripts(quiz_id: int, db: Session = Depends(get_db)):
    """List all students who have taken this quiz."""
    transcripts = db.query(Transcript).filter_by(quiz_id=quiz_id).all()
    # Group by student to show unique participants
    participants = {}
    for t in transcripts:
        key = f"{t.enrollment_id}_{t.student_name}"
        if key not in participants:
            participants[key] = {
                "name": t.student_name,
                "enrollment_id": t.enrollment_id,
                "completed_at": t.created_at,
                "id": t.id # Use one transcript ID as reference
            }
    return list(participants.values())

@app.get("/professor/transcript/{transcript_id}/export")
def export_transcript(transcript_id: int, db: Session = Depends(get_db)):
    """Exports the full dialogue of a student's assessment session as a TXT file."""
    base_t = db.query(Transcript).get(transcript_id)
    if not base_t:
        raise HTTPException(status_code=404, detail="Transcript not found")
    
    # Fetch all interactions for this specific student in this quiz
    all_interactions = db.query(Transcript).filter_by(
        quiz_id=base_t.quiz_id, 
        enrollment_id=base_t.enrollment_id
    ).order_by(Transcript.created_at).all()
    
    content = f"--- EDU RANK ASSESSMENT TRANSCRIPT ---\n"
    content += f"STUDENT: {base_t.student_name}\n"
    content += f"ENROLLMENT: {base_t.enrollment_id}\n"
    content += f"QUIZ ID: {base_t.quiz_id}\n"
    content += f"DATE: {base_t.created_at}\n"
    content += f"{'='*40}\n\n"
    
    for i, t in enumerate(all_interactions):
        content += f"Q{i+1}: {t.question.question_text if t.question else 'N/A'}\n"
        content += f"STUDENT: {t.student_answer}\n"
        content += f"{'-'*40}\n"
    
    from fastapi.responses import Response
    return Response(
        content=content,
        media_type="text/plain",
        headers={"Content-Disposition": f"attachment; filename=transcript_{base_t.enrollment_id}.txt"}
    )
